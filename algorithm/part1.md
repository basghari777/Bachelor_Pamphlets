# بخش اول

#### مرتبه زمانی:
در طراحی الگوریتم هدف استفاده از روش‌هایی برای کاهش مرتبه زمانی و کاهش تعداد گام‌های یک برنامه می‌باشد. مرتبه زمانی یا Order مدت زمان اجرا یا همان تعداد گام‌های اجرای یک برنامه را نشان می‌دهد. مرتبه زمانی الگوریتم‌ها در دسته‌های زیر قرار می‌گیرند.

<p style="direction: ltr; text-align: center">$$ O(1) < O(\log_{2} n) < O(n) < O(n\log_{2} n) < O(n^2) < O(2^n) < O(n!) < O(n^n) $$ </p>

**مثال:**

$$ O(1) $$
```
for(int i = 0; i < 5; i++)
    cout << i;
```
<br/>

$$ O(n) $$
```
for(int i = 0; i < n; i++)
    cout << i;
```
<br/>

$$ O(\log_{2} n)
```
int i = n;
while(i >= 1)
{
    i /= 2;
    cout << i;
}
```
<br/>

$$ O(n\log_{2} n) $$
```
for(int i = 0; i < n; i++)
{
    int j = n;
    while(j >= 1)
    {
        j /= 2;
        cout << j;
    }
}
```
<br/>

$$ O(n^{2}) $$
```
for(int i = 0; i < n; i++)      // $$ O(n) $$
    for(int j = 2; j < n; j++)  // $$ O(n) $$
        cout << i * j;          // $$ O(n^2) $$
```
#### تابع بازگشتی
**مثال:** مقدار f(5) را بدست آورید.
```
int f(int n)
{
    if(n <= 1)
        return n;
    return f(n - 1) + f(n - 1);
}
```


#### شمارگام‌های یک برنامه:
برای محاسبه‌ی مرتبه‌ی زمانی باید شمار گام‌های یک برنامه محاسبه شود، یعنی هر سطر از برنامه چند بار اجرا می‌شود. در ادامه با چند مثال شمار گام‌ها را محاسبه می‌کنیم.

حل معادلات بازگشتی به روش جایگزینی با استفاده از رابطه‌ی بازگشتی (با جایگذاری) از $$ n $$ شروع کرده و به عقب بر می‌گردیم تا به شرط خروجی یا مقدار اولیه رابطه بازگشتی برسیم.

### تقسیم و حل:
#### حل مسائل با استفاده از تقسیم و حل
مسائل سنگین به مسائل کوچکتری تقسیم می‌شوند، هرکدام از این مسائل کوچک را زیر مسئله می‌گویند. در نهایت حل مسائل کوچک سریع‌تر و راحت از مسائل بزرگ می‌باشد.

سپس با ترکیب حل مسائل کوچک جواب مسئله بزرگ به دست می‌آید.

#### حل مسئله جستجوی دودویی به روش تقسیم و حل:
این الگوریتم برای لیست مرتب ارائه شده است. همانطور که می‌دانید در لیست مرتب و نامرتب بدترین حالت جستجوی یک عدد روش خطی یا $$ O(n^2) $$ می‌باشد. اما در مورد لیست مرتب با جستجوی دودویی مرتبه زمانی $$ O(\log {n}) $$ خواهد بود.

#### عملکرد روش جستجوی دودویی:
در هر مرحله عنصر میانه را مشخص می‌کنیم اگر $$ x $$ برابر عنصر میانی باشد یعنی محل $$ x $$ پیدا شده است در غیر اینصورت اگر $$ x $$ بزرگتر از عنصر میانه باشد جستجو را به همین روش در نیمه راست انجام داده و اگر $$ x $$ کوچکتر از عنصر میانه باشد جستجو را در نیمه چپ انجام می‌دهیم.

این کار را آنقدر تکرار می‌کنیم تا یا $$ x $$ پیدا شود و یا با اندیس $$ h $$ برابر شود یا از آن عبور کند.

#### حل مسئله مرتب‌سازی ادغام یا Merge Sort به روش تقسیم و حل:
برای مرتب‌سازی اعداد به صورت صعودی یا نزولی از این روش استفاده می‌شود، در هر مرحله لیست به دو لیست کوچکتر تقسیم می‌شود‌، عمل تقسیم لیست تا زمانی انجام می‌شود که در آخرین تقسیم طول هر لیست برابر یک عنصر شود. آنگاه عمل ادغام و مرتب‌سازی آغاز می‌شود.

هر بار در زیرشاخه‌ها دو لیست با یکدیگر مقایسه و مرتب و ادغام می‌شوند تا زمانی که تمام لیست مرتب شود.

**نکته:** مرتبه زمانی الگوریتم مرتب‌سازی ادغام در بهترین حالت و حالت متوسط و بدترین حالت $$ O(n\log_{2} n) $$ می‌باشد.

#### حل مسئله مرتب سازی سریع به روش تقسیم و حل:
در این مرتب‌سازی اولین عنصر همیشه به عنوان عنصر محوری و یک عنصر فرضی به نام Max بعد از آخرین عنصر در نظر گرفته می‌شود. در هر مرحله شمارنده $$ i $$ از سمت چپ بعد از عنصر محوری آغاز می‌شود و شمارنده $$ j $$ از سمت راست از عنصر Max آغاز شده و در هر مرحله یکی از آن کم می‌گردد. از سمت چپ به راست باید عنصر محوری از محتوای $$ i $$ بزرگتر باشد تا $$ i $$ اضافه گردد همچنین عنصر محوری باید از محتوای $$ j $$ کوچکتر باشد تا از $$ j $$ یکی کم شود اگر الگوریتم متوقف شود یکی از شرط های زیر برقرار است:

شرط اول) اگر  $$ i < j $$ شود محتوای $$ j $$ و $$ i $$ عوض می‌شود.

شرط دوم) اگر $$ i $$ از $$ j $$ عبور کند محتوای $$ j $$ با عنصر محوری عوض می‌شود.

**نکته:** مرتبه زمانی الگوریتم مرتب‌سازی سریع در بهترین حالت و حالت متوسط $$ O(n\log_{2} n) $$ در بدترین حالت $$ O(n^2) $$ می‌باشد. بدترین حالت زمانی است که آرایه از قبل مرتب باشد.

#### حل مسئله پیدا کردن max و min یک لیست به روش تقسیم و حل:
هربار لیست به دو قسمت تقسیم می‌شود تا زمانی که حداقل و حداکثر طول لیست‌های تقسیم شده برابر "یک" یا "دو" شوند. آنگاه اگر لیست تک عنصری باشد max و min برابر این یک عنصر خواهد بود و اگر لیست دو عنصری باشد بین دو عنصر max و min به راحتی قابل تشخیص خواهد بود.


#### حل مسئله فیبوناچی با روش تقسیم و حل:
در این الگوریتم دنباله‌ای از اعداد تولید می‌شود که هر عدد با جمع دو عدد قبلی به دست می‌آید برای مثال برای محاسبه‌ی جمله‌ی بیستم دنباله‌ی فیبوناچی باید مقادیر 19 جمله قبلی محاسبه شود. مرتبه زمانی این الگوریتم $$ O(n^2) $$ و از نوع نمایی می‌باشد. 

#### ضرب ماتریس‌ها با استفاده از روش استراسن با تقسیم و حل:
عملیات ضرب ماتریس دارای مرتبه زمانی $$ O(n^3) $$ می‌باشد. اما در روش استراسن تعداد ضرب‌ها کاهش یافته و منجر به کاهش زمان اجرا و مرتبه‌ی زمانی می‌شود.

برای ضرب ماتریس‌ها به روش استراسن در هر مرحله ماتریس‌ها کوچک‌تر می‌شوند تا عمل ضرب بهتر انجام شود. تابع بازگشتی استراسن در هر مرحله 7 بار فراخوانی می‌شود.

**نکته:** منظور از مسئله کوچک این است که در آن مرحله ضرب به روش معمولی انجام می‌شود.

**نکته:** برای ضرب ماتریس‌های کوچک استفاده از روش استراسن مقرون به صرفه نیست.

---

**نکته:** در ضرب معمولی دو ماتریسی تعداد عمل ضرب برابر است با <sup>3</sup>(مرتبه ماتریس)

**نکته:** تعداد ضرب‌های روش استراسن $$ T(n) = 7T(\frac{n}{2}) $$
و در روش معمولی (برای مسئله ی کوچک): $$ T(n) = n^3 $$ برای مثال $$ T(2) = 8 $$


#### حل مسائل به روش حریصانه:
با روش حریصانه مسائلی را می‌توان حل کرد که در آن‌ها تعداد $$ n $$ ورودی وجود دارد و می‌خواهیم با بعضی محدودیت‌های خاص زیر مجموعه‌ای از این ورودی‌ها را انتخاب کنیم.

هر زیرمجموعه‌ای که شرایط و محدودیت‌های مشخص شده را دارا باشد یک جواب ممکن به شمار می‌رود. جواب‌ها باید طوری انتخاب شوند که بین جواب‌های موجود بیشترین ارزش را داشته باشند. به این جواب‌ها، جواب بهینه می‌گویند.

#### حل مسئله کوله پشتی کسری به روش حریصانه:
در این مسئله $$ n $$ شیئ داریم که هدف پر کردن کوله پشتی با این اشیا می‌باشد بطوری که ارزش کوله پشتی ماکزیمم شود و وزن آن از محدودیت مشخص شده‌ای تجاوز نکند.

اگر $$ 1 \le i \le n $$ باشد یعنی شیئ $$ i $$ام بین $$ 1 $$ تا $$ n $$ و $$ 0 \le x_i \le 1 $$ که $$ x_i $$ میزان یا مقدار انتخابی شیئ $$ i $$ام می‌باشد به شرطی که مجموع ارزش‌ها یا $$ \sum_{i=1}^{n}{p_i}{x_i} $$ بیشینه شود و مجموع وزن‌ها کمتر مساوی وزن مشخص شده باشد یعنی $$ \sum_{i=1}^{n}{w_i}{x_i} \le M $$ که $$ M $$ حداکثر وزن مجاز برای کوله پشتی می‌باشد. 

**نکته:** مرتبه زمانی الگوریتم کوله پشتی کسری $$ O(n\log {n}) $$ می‌باشد.

#### حل مسئله کدگذاری هافمن به روش حریصانه:
در این روش لیست کاراکترها را با توجه به فراوانی هر کاراکتر به صورت صعودی مرتب می‌کنیم سپس در هر مرحله درخت آن را رسم می‌کنیم. هدف این الگوریتم کاهش حجم فایل‌ها می‌باشد.

#### گراف:
هر گراف از تعدادی رأس تشکیل شده است و هر کدام از این رأس ها یا گره‌ها توسط یال‌ها به هم متصل می‌باشند. هدف اصلی مسئله پیدا کردن درخت پوشای مینیمال در یک گراف با استفاده از روش حریصانه می‌باشد.

##### الگوریتم راشال یا کراسکال:
در این روش در هر مرحله یال‌ها از لیست انتخاب می‌شوند و به درخت اضافه می‌شوند (یال‌ها به صورت صعودی مرتب شده و در لیست قرار گرفته‌اند) هر یال قبل از انتخاب بررسی می‌شود که در درخت پوشا دور ایجاد نکند.

**نکته:** در هر مرحله یک جنگل ایجاد می شود.
##### الگوریتم پریم:
در الگوریتم پریم در هر مرحله یک درخت داریم و هر بار نزدیک ترین همسایه انتخاب می‌شود طوری که دور ایجاد نکند.

**نکات:**
* مرتبه زمانی الگوریتم پریم $$ O(n^2) $$ است.
* مرتبه زمانی الگوریتم راشال برای گراف خلوت (با تعداد یال‌های کم) برابر $$ O(n\log_{2} n) $$ و برای گراف‌های شلوغ $$ O(n^2\log_{2} n) $$ می‌باشد.
* برای گراف‌های شلوغ از الگوریتم پریم و برای گراف‌های خلوت از الگوریتم راشال استفاده می‌کنیم.

#### حل مسائل به روش برنامه‌نویسی پویا:
در این گونه مسائل ابتدا نمونه‌های کوچکتر اجرا می‌شوند سپس حاصل آن‌ها در یک آرایه ذخیره می‌شود، در ادامه نمونه‌های کوچکتر از نمونه‌های بزرگتر به دست می‌آیند.

در مسائلی که نمونه‌های کوچک به یکدیگر وابستگی ندارند از روش تقسیم و حل استفاده می‌شود اما در مسائلی که نمونه‌های کوچک با یکدیگر ارتباط داشته باشند از روش پویا استفاده می‌کنیم.

روش تقسیم و حل یک روش **کل به جزء** بوده اما روش پویا یک روش **جزء به کل** است.

#### حل مسئله فیبوناچی به روش برنامه‌نویسی پویا:
در این روش برای به دست آوردن جمله $$ n $$ام دنباله باید جملات قبلی را بدست آوریم. به همین منظور یک آرایه $$ n $$تایی در نظر می‌گیریم و از ابتدای آرایه با مجموع هر دو جمله، جمله بعدی را به دست می‌آوریم. مرتبه‌ی زمانی این الگوریتم $$ O(n) $$ می‌باشد و نیاز به یک حلقه for به طول $$ n $$ خواهد بود.

#### حل مسئله پیدا کردن کوتاهترین مسیر توسط الگوریتم فلوید (Floyd):
فرض کنید یک گراف جهتدار شامل $$ n $$ رأس و $$ e $$ لبه می‌باشد. این گراف یک گراف وزن‌دار است که یک عدد غیر منفی به عنوان وزن وجود دارد این عدد نشان دهنده‌ی فاصله بین دو رأس است. برای اینکه کوتاهترین فاصله را از هر رأس به رأس دیگر بدست آوریم مراحل زیر را انجام می دهیم:
1.	در مرحله‌ی اول مسیرهای مستقیم را بدست می‌آوریم.
2.	در گام دوم کوتاه‌ترین فاصله بین دو رأس را با یک رأس واسط محاسبه می‌کنیم.
3.	در گام دوم کوتاه‌ترین فاصله بین دو رأس را با یک گره واسط محاسبه می‌کنیم.
4.	این عمل را آن قدر انجام می‌دهیم تا تمام رأس‌های واسط در صورت امکان انتخاب شوند.
5.	در هر مرحله اطلاعات را در یک ماتریس ذخیره می‌کنیم و ممکن است در گام‌های جدید مقادیر بروز رسانی شوند.
